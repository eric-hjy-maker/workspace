###### 视频地址：https://www.bilibili.com/video/BV1KL4y1K7Ry?p=1
##### 几种引用方式 
    强软（堆不够就回收，适合缓存）弱（下次gc就回收）虚（给垃圾回收器用的，清堆外内存）
##### A(undolog保证，要么全执行)C（其他三个特性保证）I（隔离性，MVCC多版本并发控制）D（持久化：redolog保证，日志写的快）
##### hashmap 有哪些线程安全的方式？
##### hashmap 的扩容优化？
    初始 16，每次扩容 2 的指数倍，移动，要么原位置，要么 + 扩容长度
##### MVCC 实现原理？ 
##### mybatis优缺点？
##### mybatis #{} 和 ${} 的区别？ 
    #{} 防止sql注入，${} 会直接拼接字符串
##### mysql 事务隔离级别？ 
    幻读针对列
##### mysql 复制原理？ 
    binlog，主从复制
##### mysql 聚簇索引和非聚簇索引？ 
    innodb 聚簇索引：主键索引，非聚簇索引：非主键索引
##### mysql 锁的类型？ 
    表锁，行锁（多行，非区间），记录锁（单行），页锁（操作系统上的页）等
##### mysql 为什么要读写分离？ 有一个sql锁表时，暂时不能读，读写分离解决这个问题
##### mysql 执行计划？ 
    id 多个查询的顺序； type 访问类型（至少range级别）； 
    key 用到了哪个索引； 
    rows 预估扫描的行数； extra 一些额外信息
##### springmvc工作流程？ 要再去手写一下
##### spring 事务传播行为？ 
    required (默认) 有事务就用，没有就新建（try catch 没用）；
    nested 有就嵌套，没有就新建（try catch捕获异常后，不会回滚）
##### spring 设计模式及应用场景？ 
    工厂模式（BeanFactory）； 代理模式（aop）； 
    单例模式（spring bean）； 模板模式（jdbcTemplate）；
    适配器模式（HandlerAdapter）；
##### mysql 索引类型？ 
    普通索引，唯一索引，主键索引，联合索引，全文索引
##### mysql 慢查询怎么处理？
    1. 开启慢查询日志，定位哪个sql出问题了
    2. 是否加载了多余的行或列
    3. 查看执行计划，是否使用到了索引，修改索引
    4. 如果sql无法优化，可考虑减小区间
##### MVCC Multi Version Concurrency Control 多版本并发控制
##### 嵌入式服务器？ 
    之前开发要把项目放在服务器上，springboot内置tomcat就可以直接启动
##### JDK1.8 新特性？ 
    lambda表达式，函数式接口，stream流，方法引用，接口的默认方法，接口的静态方法
##### 接口和抽象类的区别？
    接口：用于表现一些特征，比如 flyable，可飞的
    抽象类：用于表现一些事物，比如 animal，动物
##### 分布式锁的解决方案？
    redis，zookeeper，数据库
##### redis 分布式锁死锁的情况？
    1. 没有过期时间，没有删除锁，导致死锁
    2. 程序中断，没有设置过期时间
##### 你设计微服务时遵循什么原则？
    1. 单一职责原则
    2. 服务自治原则： 每个服务可以单独开发，测试，构建，古树，运行
    3. 轻量通信原则： 让每个服务之间调用轻量级，并且能够跨平台，如RestFul风格，消息队列等
    4. 粒度进化原则： 服务的粒度要逐步细化，不要一开始就设计成大而全的服务（逐步拆分服务）
##### Spring 如何解决魂环依赖问题的？
    三级缓存， 提前暴露对象， aop
    先简单说一下bean的创建过程：实例化、属性填充、初始化
    1。 先创建 A 对象， 实例化 A 对象，此时A对象中的 b 属性为null
    2. 从容其中找到 B 对象，实例化 B 对象，此时 B 对象中的 a 属性为null
    形成闭环的原因
        A 对象是存在的，只不过不是一个完整的对象，所以先赋值这个不完整的对象给 B 对象中的 a 属性
    一级缓存：放的完整对象
    二级缓存：放的不完整对象
    三级缓存：(a, lambda(a的原始对象， beanName，beanDefinition)) 返回AOP对象，提前AOP用的
##### Spring中的设计模式？
    单例模式：bean
    原型模式：prototype
    工厂模式：beanFactory
    模板方法：JdbcTemplate
    代理模式：AOP
    适配器模式：HandlerAdapter
##### AOP 的底层实现？
##### Required 和 Nested 回滚的区别？
    Required: 内层方法的异常被捕获，外层方法的事务照样会回滚
    Nested: 内层方法的异常被捕获，外层方法的事务不会回滚
##### Required_New 和 Nested 回滚的区别？
    Required_New: 外层事务异常时，内层事务不会回滚
    Nested: 外层事务回滚，内层也会回滚
##### Mybatis 获取自动生成的主键？
    使用 insert 标签的 useGeneratedKeys = true， keyProperty = 'id'，插入完成后，id 属性会被自动填充
##### Mybatis 的缓存设计？ 一级缓存和二级缓存？
    一级缓存：sqlSession级别的缓存，一级缓存是一直开启的，不需要手动开启
    二级缓存：namespace级别的缓存，二级缓存需要手动开启
    一级缓存失效的情况：
        1. sqlSession不同
        2. sqlSession相同，查询条件不同
        3. sqlSession相同，两次查询之间执行了增删改操作
        4. sqlSession相同，手动清除了一级缓存
    二级缓存失效的情况：
        1. 不同的namespace
        2. 不同的sqlSession
        3. 不同的查询条件
        4. 增删改操作
        5. 手动清除了二级缓存
##### CMS consurrent mark sweep 并发标记清除GC？
    1. 初始标记：标记GC Roots能直接关联到的对象
    2. 并发标记：进行GC Roots Tracing的过程
    3. 重新标记：修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录
    4. 并发清除：清除所有标记对象
##### G1 GC？
    1. 初始标记：标记GC Roots能直接关联到的对象，暂停用户线程
    2. 并发标记：进行GC Roots Tracing的过程，与用户线程并发执行
    3. 最终标记：修正垃圾标记，需暂停用户线程
    4. 筛选回收：对各个Region回收价值和成本进行排序，选择价值最大的Region进行回收，根据用户期望的GC停顿时间制定回收计划
##### JVM 常用命令
    jps：查看当前运行的java进程
    jinfo：查看jvm配置信息
    jstat：查看jvm运行时的状态
    jmap：查看jvm内存使用情况
    jstack：查看jvm线程状态
    jhat：查看jvm堆内存快照
##### javac 编译器干了什么事儿？
    java 文件转为 .class 文件
##### 编译原理？
    词法分析：将源代码转为 token 流
    语法分析：将 token 流转为 AST
    语义分析：将 AST 转为中间代码
    优化：将中间代码转为目标代码
    代码生成：将目标代码转为机器码
##### 类加载机制？
    1. 加载：将类的.class文件加载到内存中，并将这些静态数据转换为方法区的运行时数据结构
    2. 链接-验证：确保加载的类信息符合JVM规范，不会危害虚拟机自身安全
    3. 链接-准备：为类的静态变量分配内存，并将其初始化为默认值
    4. 链接-解析：将类中的符号引用转为直接引用
    5. 初始化：为类的静态变量赋予正确的初始值




